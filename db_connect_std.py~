import os
import mysql.connector
from mysql.connector import pooling
from contextlib import contextmanager
from dotenv import load_dotenv

load_dotenv()

class Database:
    """Gestisce un pool di connessioni MySQL in modo centralizzato."""
    def __init__(self):
        self.config = {
            "host": os.getenv("DB_HOST"),
            "port": int(os.getenv("DB_PORT", 3306)),
            "user": os.getenv("DB_USER"),
            "password": os.getenv("DB_PASSWORD"),
            "database": os.getenv("DB_NAME"),
            "ssl_disabled": os.getenv("DB_SSL_DISABLED", "False").lower() == "true"
        }

        # üîπ Creazione del pool di connessioni
        self.pool = pooling.MySQLConnectionPool(
            pool_name="mypool",
            pool_size=5,
            **self.config
        )

    @contextmanager
    def get_connection(self):
        """Restituisce una connessione dal pool e la chiude automaticamente."""
        conn = None
        try:
            conn = self.pool.get_connection()
            yield conn
        finally:
            if conn and conn.is_connected():
                conn.close()


db = Database()  # Istanziamo l'oggetto Globale Database

class RequestLogDAO:
    """DAO per la tabella request_log (richieste ricevute dal server)."""

    def insert(self, request_text: Any, response_text: Any, signal_id: Optional[int] = None) -> int:
        query = """
            INSERT INTO request_log (request, response, signal_id)
            VALUES (%s, %s, %s)
        """

        with db.get_connection() as conn:
            cursor = conn.cursor()
            request_json = json.dumps(request_text) if isinstance(request_text, dict) else request_text
            response_json = json.dumps(response_text) if isinstance(response_text, dict) else response_text
            cursor.execute(query, (request_json, response_json, signal_id))
            conn.commit()
            return cursor.lastrowid

    def update_field(self, id_request: int, field_name: str, new_value: Any) -> int:
        query = f"UPDATE request_log SET {field_name} = %s WHERE id_request = %s"
        with db.get_connection() as conn:
            cursor = conn.cursor()
            val = json.dumps(new_value) if isinstance(new_value, dict) else new_value
            cursor.execute(query, (val, id_request))
            conn.commit()
            return cursor.rowcount




class ApiRequestDAO:
    """DAO per la tabella api_requests (chiamate fatte dal server verso Bitget)."""

    def insert(self, request_text: Any, response_text: Any, signal_id: Optional[int] = None) -> int:
        query = """
            INSERT INTO api_requests (
                endpoint, body, headers, payload,
                response_status, response_body, response_json,
                response_data, response_code, response_msg,
                signal_id
            ) VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
        """

        with db.get_connection() as conn:
            cursor = conn.cursor()

            req = request_text if isinstance(request_text, dict) else json.loads(request_text)
            res = response_text if isinstance(response_text, dict) else json.loads(response_text)

            values = (
                req.get("endpoint"),
                req.get("body"),
                req.get("headers"),
                req.get("payload"),
                res.get("response_status"),
                res.get("response_body"),
                res.get("response_json"),
                res.get("response_data"),
                res.get("response_code"),
                res.get("response_msg"),
                signal_id
            )

            cursor.execute(query, values)
            conn.commit()
            return cursor.lastrowid




class DatabaseService:
    """Gestisce in modo centralizzato l‚Äôinserimento e aggiornamento nei DAO."""

    def __init__(self):
        self.request_log_dao = RequestLogDAO()
        self.api_request_dao = ApiRequestDAO()

    def log_incoming_request(self, request_text, response_text, signal_id=None):
        try:
            inserted_id = self.request_log_dao.insert(request_text, response_text, signal_id)
            print(f"‚úÖ Inserita richiesta in request_log (id={inserted_id}, signal_id={signal_id})")
            return inserted_id
        except Error as e:
            print(f"‚ùå Errore DB durante l‚Äôinserimento in request_log: {e}")
            return None

    def log_outgoing_api(self, request_text, response_text, signal_id=None):
        try:
            inserted_id = self.api_request_dao.insert(request_text, response_text, signal_id)
            print(f"‚úÖ Inserita richiesta API (id={inserted_id}, signal_id={signal_id})")
            return inserted_id
        except Error as e:
            print(f"‚ùå Errore DB durante l‚Äôinserimento in api_requests: {e}")
            return None
